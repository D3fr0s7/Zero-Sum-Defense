<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zero-Sum Defense</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, collection, addDoc, updateDoc, writeBatch, query, where, getDocs, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- CONSTANTS ---
        const BOARD_ROWS = 8;
        const BOARD_COLS = 10;
        const NEXUS_HP = 3;
        const BUILDING_HP = 1;
        const PYLON_COST = 1;
        const MIRROR_COST = 1;
        const NEXUS_MOVE_RANGE = 3;
        const INITIAL_ENERGY = 10;

        const AVAILABLE_COLORS = ['Blue', 'Red', 'Green', 'Yellow', 'Purple', 'Orange', 'Pink', 'Cyan'];
        const COLOR_MAP = {
            'Blue':   { bg: 'bg-blue-900/20',   stroke: 'stroke-cyan-400',       border: 'border-cyan-400'   },
            'Red':    { bg: 'bg-red-900/20',    stroke: 'stroke-rose-400',       border: 'border-rose-400'   },
            'Green':  { bg: 'bg-green-900/20',  stroke: 'stroke-green-400',      border: 'border-green-400'  },
            'Yellow': { bg: 'bg-yellow-900/20', stroke: 'stroke-yellow-400',     border: 'border-yellow-400' },
            'Purple': { bg: 'bg-purple-900/20', stroke: 'stroke-purple-400',     border: 'border-purple-400' },
            'Orange': { bg: 'bg-orange-900/20', stroke: 'stroke-orange-400',     border: 'border-orange-400' },
            'Pink':   { bg: 'bg-pink-900/20',   stroke: 'stroke-pink-400',       border: 'border-pink-400'   },
            'Cyan':   { bg: 'bg-cyan-900/20',   stroke: 'stroke-cyan-400',       border: 'border-cyan-400'   }
        };

        const DIRECTIONS = {
            'N': [-1, 0], 'NE': [-1, 1], 'E': [0, 1], 'SE': [1, 1],
            'S': [1, 0], 'SW': [1, -1], 'W': [0, -1], 'NW': [-1, -1]
        };

        // --- DOM Elements ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        // Views
        const profileView = $('#profile-view');
        const lobbyView = $('#lobby-view');
        const lobbyListView = $('#lobby-list-view');
        const createLobbyView = $('#create-lobby-view');
        const waitingRoomView = $('#waiting-room-view');
        const gameView = $('#game-view');
        const modalView = $('#modal-view');

        // Profile
        const profileDisplayNameInput = $('#profile-display-name');
        const profileColorSelect = $('#profile-color-select');
        const saveProfileBtn = $('#save-profile-btn');

        // Lobby
        const userIdDisplay = $('#user-id-display');
        const userDisplayNameDisplay = $('#user-display-name-display');
        const singlePlayerBtn = $('#single-player-btn');
        const multiPlayerBtn = $('#multi-player-btn');

        // Lobby List
        const lobbyListContainer = $('#lobby-list-container');
        const refreshLobbiesBtn = $('#refresh-lobbies-btn');
        const showCreateLobbyBtn = $('#show-create-lobby-btn');
        const backToMainMenuBtn = $('#back-to-main-menu-btn');

        // Create Lobby
        const lobbyNameInput = $('#lobby-name-input');
        const energyPoolSelect = $('#energy-pool-select');
        const hostColorSelect = $('#host-color-select');
        const createLobbyBtn = $('#create-lobby-btn');
        const cancelCreateLobbyBtn = $('#cancel-create-lobby-btn');

        // Waiting Room
        const waitingLobbyName = $('#waiting-lobby-name');
        const waitingPlayer1Name = $('#waiting-player1-name');
        const waitingPlayer1Color = $('#waiting-player1-color');
        const waitingPlayer2Name = $('#waiting-player2-name');
        const waitingPlayer2Color = $('#waiting-player2-color');
        const startGameBtn = $('#start-game-btn');
        const leaveLobbyBtn = $('#leave-lobby-btn');

        // Game
        const gameIdDisplay = $('#game-id-display');
        const playerNumberDisplay = $('#player-number');
        const currentTurnDisplay = $('#current-turn');
        const currentPhaseDisplay = $('#current-phase');
        const energyPoolDisplay = $('#energy-pool');
        const playerBudgetDisplay = $('#player-budget');
        const gameBoard = $('#game-board');
        const gameLog = $('#game-log');
        const modalMessage = $('#modal-message');
        const newGameBtn = $('#new-game-btn');

        // Controls
        const setupControls = $('#setup-controls');
        const setupWaitingMsg = $('#setup-waiting-msg');
        const confirmNexusBtn = $('#confirm-nexus-btn');
        const buyMoveControls = $('#buy-move-controls');
        const attackControls = $('#attack-controls');
        const waitingControls = $('#waiting-controls');
        const placePylonBtn = $('#place-pylon-btn');
        const placeMirrorBtn = $('#place-mirror-btn');
        const moveNexusBtn = $('#move-nexus-btn');
        const cancelActionBtn = $('#cancel-action-btn');
        const endPhaseBtn = $('#end-phase-btn');
        const skipAttackBtn = $('#skip-attack-btn');

        // New bottom indicator elements
        const bottomPhaseDisplay = $('#bottom-phase-display');
        const bottomNextPhaseBtn = $('#bottom-next-phase-btn');

        // --- App State ---
        let db, auth;
        let currentUserId = null;
        let userProfile = null;
        let currentGameId = null;
        let currentGame = null;
        let playerIndex = -1;
        let unsubscribeGame = null;
        let currentAction = null; // 'place-pylon', 'place-mirror', 'move-nexus-select', 'setup-nexus-select'
        let selectedUnitLocation = null; // for nexus move or setup
        let currentBudget = 0;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- SVGs for Units ---
        const NEXUS_SVG = `
            <svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
            </svg>`;
        const PYLON_SVG = `
            <svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2L7 22h10L12 2z"></path>
            </svg>`;
        const MIRROR_SVG = `
            <svg class="w-full h-full" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <line x1="2" y1="22" x2="22" y2="2"></line>
            </svg>`;

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                // const firebaseConfig = JSON.parse(__firebase_config); // Old config
                const firebaseConfig = {
                    apiKey: "AIzaSyBTK04oSfdM5K0w8sspYn42OQzCGFf8AMM",
                    authDomain: "zero-sum-defense.firebaseapp.com",
                    projectId: "zero-sum-defense",
                    storageBucket: "zero-sum-defense.firebasestorage.app",
                    messagingSenderId: "484724724929",
                    appId: "1:484724724929:web:104009b0c91ee8559a3040"
                };
                
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); // Enable Firestore logging

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        userIdDisplay.textContent = currentUserId;
                        await loadUserProfile();
                    } else {
                        // No user, attempt to sign in
                        signIn();
                    }
                });
            } catch (error) {
                console.error("Firebase Init Error:", error);
                showModal(`Error: Could not initialize. Details: ${error.message}`);
            }
        }

        async function signIn() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Firebase Sign-In Error:", error);
                showModal(`Error: Could not sign in. Details: ${error.message}`);
            }
        }

        // --- Profile Functions ---
        async function loadUserProfile() {
            if (!currentUserId) return;
            const profileRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'profile', 'settings');
            try {
                const docSnap = await getDoc(profileRef);
                if (docSnap.exists()) {
                    userProfile = docSnap.data();
                    userDisplayNameDisplay.textContent = userProfile.displayName;
                    showView('lobby');
                } else {
                    // First time user, show profile creation
                    populateColorSelect(profileColorSelect);
                    showView('profile');
                }
            } catch (error) {
                console.error("Load Profile Error:", error);
                showModal("Error loading user profile.");
            }
        }

        async function saveUserProfile() {
            const displayName = profileDisplayNameInput.value.trim();
            const preferredColor = profileColorSelect.value;
            if (displayName.length < 3) {
                return showError("Display name must be at least 3 characters.");
            }

            const profileData = { displayName, preferredColor };
            const profileRef = doc(db, 'artifacts', appId, 'users', currentUserId, 'profile', 'settings');
            try {
                await setDoc(profileRef, profileData);
                userProfile = profileData;
                userDisplayNameDisplay.textContent = userProfile.displayName;
                showView('lobby');
            } catch (error) {
                console.error("Save Profile Error:", error);
                showError("Could not save profile.");
            }
        }

        // --- Lobby Functions ---

        function showLobbyList() {
            showView('lobbyList');
            refreshLobbies();
        }

        async function refreshLobbies() {
            if (!db) return;
            lobbyListContainer.innerHTML = '<p class="text-gray-400">Loading open lobbies...</p>';
            const gamesRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games');
            const q = query(gamesRef, where("status", "==", "waitingForOpponent"));
            
            try {
                const querySnapshot = await getDocs(q);
                if (querySnapshot.empty) {
                    lobbyListContainer.innerHTML = '<p class="text-gray-400">No open lobbies found. Create one!</p>';
                    return;
                }
                
                lobbyListContainer.innerHTML = ''; // Clear
                querySnapshot.forEach((doc) => {
                    const game = doc.data();
                    const host = game.players[0];
                    const el = document.createElement('div');
                    el.className = 'flex justify-between items-center p-3 bg-gray-700/50 rounded-lg border border-indigo-500/30';
                    el.innerHTML = `
                        <div>
                            <p class="text-lg font-bold text-cyan-400">${game.lobbyName}</p>
                            <p class="text-sm text-gray-300">Host: ${host.displayName} (${host.color})</p>
                            <p class="text-sm text-gray-400">Energy: ${game.maxEnergy}</p>
                        </div>
                        <button data-id="${doc.id}" class="join-lobby-btn bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg transition-all">Join</button>
                    `;
                    lobbyListContainer.appendChild(el);
                });

                // Add event listeners to join buttons
                $$('.join-lobby-btn').forEach(btn => {
                    btn.addEventListener('click', () => joinLobby(btn.dataset.id));
                });

            } catch (error) {
                console.error("Error refreshing lobbies:", error);
                lobbyListContainer.innerHTML = '<p class="text-red-400">Error loading lobbies.</p>';
            }
        }

        function showCreateLobby() {
            populateColorSelect(hostColorSelect, userProfile.preferredColor);
            energyPoolSelect.value = "10";
            lobbyNameInput.value = `${userProfile.displayName}'s Game`;
            showView('createLobby');
        }

        async function createLobby() {
            if (!currentUserId || !userProfile) return;

            const lobbyName = lobbyNameInput.value.trim();
            if (!lobbyName) return showError("Lobby name is required.");

            const hostColor = hostColorSelect.value;
            const maxEnergy = parseInt(energyPoolSelect.value);

            const gameData = {
                lobbyName: lobbyName,
                status: 'waitingForOpponent', // Host waits for P2
                players: [
                    {
                        userId: currentUserId,
                        displayName: userProfile.displayName,
                        color: hostColor,
                        nexusLocation: null,
                        nexusHP: NEXUS_HP,
                        buildings: []
                    }
                ],
                maxEnergy: maxEnergy,
                energyPool: maxEnergy,
                pendingEnergyRefund: 0,
                turn: 0, // Host (P1) always starts
                phase: 'setup', 
                lastShotVector: null,
                log: [`Lobby '${lobbyName}' created by ${userProfile.displayName}.`]
            };

            try {
                const collRef = collection(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games');
                const gameDocRef = await addDoc(collRef, gameData);
                listenToGame(gameDocRef.id); // Host starts listening
            } catch (error) {
                console.error("Create Lobby Error:", error);
                showError("Could not create lobby.");
            }
        }

        async function joinLobby(gameId) {
            if (!gameId || !currentUserId || !userProfile) return;

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', gameId);

            try {
                const gameSnap = await getDoc(gameRef);
                if (!gameSnap.exists()) {
                    return showError("Game not found.");
                }

                const gameData = gameSnap.data();
                const host = gameData.players[0];

                if (gameData.status !== 'waitingForOpponent') {
                    return showError("Lobby is no longer open.");
                }
                if (host.userId === currentUserId) {
                    // This is the host rejoining, just listen
                    listenToGame(gameId);
                    return;
                }

                // Determine P2 color
                let playerColor = userProfile.preferredColor;
                if (host.color === playerColor) {
                    playerColor = AVAILABLE_COLORS.find(c => c !== host.color) || 'Red'; // Get first available
                }
                
                const p2Data = {
                    userId: currentUserId,
                    displayName: userProfile.displayName,
                    color: playerColor,
                    nexusLocation: null,
                    nexusHP: NEXUS_HP,
                    buildings: []
                };
                
                await updateDoc(gameRef, {
                    players: [host, p2Data], // Now full
                    status: 'waitingForHostStart', // Waiting for host to click "Start"
                    log: [...gameData.log, `${userProfile.displayName} joined as Player 2.`]
                });

                listenToGame(gameId); // P2 starts listening

            } catch (error) {
                console.error("Join Lobby Error:", error);
                showError("Could not join lobby.");
            }
        }

        async function leaveLobby() {
            if (!currentGameId || !currentGame || playerIndex === -1) return;

            // Simple "back" button if game hasn't started
            if (currentGame.status === 'waitingForOpponent' || currentGame.status === 'waitingForHostStart') {
                 if (unsubscribeGame) unsubscribeGame();
                 unsubscribeGame = null;
                 currentGameId = null;
                 currentGame = null;
                 playerIndex = -1;
                 showView('lobbyList'); // Go back to lobby list
                 refreshLobbies();
                 // TODO: If host leaves, delete lobby? If P2 leaves, update players array?
                 // For now, simple exit.
            }
        }

        async function startGame() {
            if (!currentGameId || currentGame.status !== 'waitingForHostStart' || playerIndex !== 0) return;

             const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
             try {
                await updateDoc(gameRef, {
                    status: 'inProgress',
                    phase: 'setup',
                    turn: 0,
                    log: [...currentGame.log, `Host started the game! Both players, place your Nexus.`]
                });
                // listener will pick this up and renderGame() will show the board
             } catch (error) {
                 console.error("Start Game Error:", error);
                 showError("Could not start game.");
             }
        }

        // --- Game Listener ---
        function listenToGame(gameId) {
            currentGameId = gameId;
            gameIdDisplay.textContent = gameId;

            if (unsubscribeGame) {
                unsubscribeGame();
            }

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', gameId);
            unsubscribeGame = onSnapshot(gameRef, (doc) => {
                if (!doc.exists()) {
                    showModal("Error: Game data not found or deleted.", true);
                    return;
                }
                currentGame = doc.data();
                playerIndex = currentGame.players.findIndex(p => p.userId === currentUserId);

                if (playerIndex === -1 && currentGame.status === 'inProgress') {
                    // User is a spectator (or joined late)
                    showError("You are not a player in this game. Spectator mode active.");
                    // TODO: Implement spectator mode properly
                }
                
                // Route to the correct view based on game status
                switch (currentGame.status) {
                    case 'waitingForOpponent':
                    case 'waitingForHostStart':
                        renderWaitingRoom();
                        showView('waitingRoom');
                        break;
                    case 'inProgress':
                        renderGame();
                        showView('game');
                        break;
                    case 'gameOver':
                        renderGame(); // Show final board state
                        const winner = currentGame.players[currentGame.winner];
                        const winnerName = (winner.userId === currentUserId) ? "You" : winner.displayName;
                        showModal(`Game Over. ${winnerName} wins!`, true);
                        break;
                }
            });
        }

        // --- Render Functions ---
        function renderWaitingRoom() {
            if (!currentGame) return;

            const p1 = currentGame.players[0];
            const p2 = currentGame.players.length > 1 ? currentGame.players[1] : null;

            waitingLobbyName.textContent = currentGame.lobbyName;
            
            // Player 1 (Host)
            waitingPlayer1Name.textContent = p1.displayName;
            waitingPlayer1Color.textContent = p1.color;
            waitingPlayer1Color.className = `p-2 rounded-lg ${COLOR_MAP[p1.color].border} border-2`;

            // Player 2
            if (p2) {
                waitingPlayer2Name.textContent = p2.displayName;
                waitingPlayer2Color.textContent = p2.color;
                waitingPlayer2Color.className = `p-2 rounded-lg ${COLOR_MAP[p2.color].border} border-2`;
            } else {
                waitingPlayer2Name.textContent = "Waiting for opponent...";
                waitingPlayer2Color.textContent = "??";
                waitingPlayer2Color.className = `p-2 rounded-lg border-gray-500 border-2`;
            }

            // Controls
            if (playerIndex === 0) { // Is Host
                startGameBtn.classList.remove('hidden');
                startGameBtn.disabled = !p2; // Enable only when P2 joins
            } else { // Is P2
                startGameBtn.classList.add('hidden');
            }
        }

        function renderGame() {
            if (!currentGame) return;

            const isMyTurn = currentGame.turn === playerIndex;
            const myPlayer = currentGame.players[playerIndex];
            const p1 = currentGame.players[0];
            const p2 = currentGame.players[1];
            // Ensure p2 exists before trying to access properties
            const turnPlayer = currentGame.players[currentGame.turn];

            // Render Status
            if (myPlayer) {
                playerNumberDisplay.textContent = `${myPlayer.displayName} (P${playerIndex + 1})`;
                playerNumberDisplay.className = `text-lg font-bold ${COLOR_MAP[myPlayer.color].border} border-b-2`;
            }
            if (turnPlayer) {
                currentTurnDisplay.textContent = `${turnPlayer.displayName} (P${currentGame.turn + 1})`;
                currentTurnDisplay.className = `text-lg font-bold ${COLOR_MAP[turnPlayer.color].border} border-b-2`;
            }
            currentPhaseDisplay.textContent = currentGame.phase;
            energyPoolDisplay.textContent = currentGame.energyPool;

            // Update bottom phase indicator
            bottomPhaseDisplay.textContent = currentGame.phase;
            if (currentGame.phase === 'buyMove') {
                bottomPhaseDisplay.className = 'text-2xl font-bold text-center text-yellow-300';
            } else if (currentGame.phase === 'attack') {
                bottomPhaseDisplay.className = 'text-2xl font-bold text-center text-red-400';
            } else {
                bottomPhaseDisplay.className = 'text-2xl font-bold text-center text-gray-300';
            }

            // Calculate Budget
            const myPylons = (myPlayer && myPlayer.buildings) ? myPlayer.buildings.filter(b => b.type === 'pylon').length : 0;
            currentBudget = (isMyTurn && currentGame.phase === 'buyMove') ? (1 + myPylons) : 0;
            playerBudgetDisplay.textContent = currentBudget;

            // Render Board
            renderBoard();

            // Render Controls
            renderControls(isMyTurn);

            // Render Log
            gameLog.innerHTML = currentGame.log.map(msg => `<p class="text-sm">${msg}</p>`).join('');
            gameLog.scrollTop = gameLog.scrollHeight;

            // Check Game Over
            if (currentGame.status === 'gameOver') {
                const winnerName = currentGame.players[currentGame.winner].displayName;
                showModal(`Game Over. ${winnerName} wins!`, true);
            }
        }

        function renderBoard() {
            if (playerIndex === -1) return; // Don't render board if not a player

            gameBoard.innerHTML = '';
            const myZoneStart = (playerIndex === 0) ? 0 : 5;
            const myZoneEnd = (playerIndex === 0) ? 5 : 10;
            const p1Color = COLOR_MAP[currentGame.players[0].color];
            const p2Color = (currentGame.players[1]) ? COLOR_MAP[currentGame.players[1].color] : COLOR_MAP['Red']; // Fallback
            const myColor = (playerIndex === 0) ? p1Color : p2Color;
            const enemyColor = (playerIndex === 0) ? p2Color : p1Color;

            for (let r = 0; r < BOARD_ROWS; r++) {
                for (let c = 0; c < BOARD_COLS; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell relative aspect-square border border-indigo-500/30 transition-all duration-150';
                    cell.dataset.r = r;
                    cell.dataset.c = c;

                    const isMyZone = c >= myZoneStart && c < myZoneEnd;
                    const isEnemyZone = !isMyZone;

                    if (isMyZone) {
                        cell.classList.add(myColor.bg);
                    } else {
                        cell.classList.add('shroud-wall', 'bg-gray-800/50', 'backdrop-blur-sm');
                    }

                    // Find and render units
                    const unit = getUnitAt(r, c);
                    if (unit) {
                        const { type, hp, isMine, owner } = unit;
                        
                        // HIDDEN INFORMATION: Only render my units, or enemy units in my zone
                        if (isMine || isMyZone) {
                            let svg = '';
                            let unitColor = (owner === 0) ? p1Color.stroke : p2Color.stroke;
                            
                            if (type === 'nexus') {
                                svg = NEXUS_SVG;
                                cell.innerHTML = `<div class="unit p-1 ${unitColor}">${svg}</div><div class="hp">${hp}/${NEXUS_HP}</div>`;
                            } else {
                                svg = (type === 'pylon') ? PYLON_SVG : MIRROR_SVG;
                                cell.innerHTML = `<div class="unit p-2 ${unitColor}">${svg}</div><div class="hp">${hp}/${BUILDING_HP}</div>`;
                            }
                        }
                    }

                    // Add highlights for actions
                    if (isMyZone) {
                        if (currentGame.phase === 'setup' && currentAction === 'setup-nexus-select') {
                            if (!unit) cell.classList.add('hover:bg-green-500/30', 'cursor-pointer');
                            if (selectedUnitLocation && r === selectedUnitLocation[0] && c === selectedUnitLocation[1]) {
                                cell.classList.add('bg-green-500/50', 'border-green-400');
                            }
                        }
                        else if (currentAction === 'place-pylon' || currentAction === 'place-mirror') {
                            if (!unit) cell.classList.add('hover:bg-green-500/30', 'cursor-pointer');
                        } else if (currentAction === 'move-nexus-select' && unit && unit.type === 'nexus' && unit.isMine) {
                            cell.classList.add('hover:bg-yellow-500/30', 'cursor-pointer', 'animate-pulse');
                        } else if (currentAction === 'move-nexus-target') {
                             if (isValidNexusMove(selectedUnitLocation, [r, c]) && !unit) {
                                cell.classList.add('hover:bg-yellow-500/30', 'cursor-pointer');
                             }
                        }
                    }

                    gameBoard.appendChild(cell);
                }
            }
        }

        function renderControls(isMyTurn) {
            [setupControls, buyMoveControls, attackControls, waitingControls].forEach(c => c.classList.add('hidden'));
            setupWaitingMsg.classList.add('hidden');
            bottomNextPhaseBtn.classList.add('hidden'); // Always hide bottom button by default

            if (playerIndex === -1) {
                waitingControls.classList.remove('hidden');
                return;
            }

            // Setup phase logic (not turn-based)
            if (currentGame.phase === 'setup') {
                if (!currentGame.players[playerIndex].nexusLocation) {
                    // This player hasn't placed
                    setupControls.classList.remove('hidden');
                    currentAction = 'setup-nexus-select';
                    confirmNexusBtn.disabled = !selectedUnitLocation; // Enable only if a cell is selected
                } else {
                    // This player has placed, check opponent
                    const opponent = currentGame.players[(playerIndex + 1) % 2];
                    if (!opponent || !opponent.nexusLocation) {
                        setupWaitingMsg.classList.remove('hidden'); // Show waiting message
                    }
                }
                return; // End control render for setup
            }

            // Post-setup is turn-based
            if (!isMyTurn) {
                waitingControls.classList.remove('hidden'); // Show waiting message
                return;
            }
            
            // It is my turn
            switch(currentGame.phase) {
                // case 'setup': // Handled above
                //     break;
                case 'buyMove':
                    buyMoveControls.classList.remove('hidden');
                    bottomNextPhaseBtn.classList.remove('hidden'); // Show bottom button
                    // Toggle button disabled states
                    placePylonBtn.disabled = (currentGame.energyPool < PYLON_COST || currentBudget < PYLON_COST);
                    placeMirrorBtn.disabled = (currentGame.energyPool < MIRROR_COST || currentBudget < MIRROR_COST);
                    break;
                case 'attack':
                    attackControls.classList.remove('hidden');
                    // Disable all attack buttons by default
                    $$('#attack-controls button[data-dir]').forEach(btn => btn.disabled = false);

                    // Disable reverse-shot button
                    const lastVec = currentGame.lastShotVector;
                    if (lastVec) {
                        const [lastDx, lastDy] = lastVec;
                        const reverseVec = [-lastDx, -lastDy];
                        for (const [dir, vec] of Object.entries(DIRECTIONS)) {
                            if (vec[0] === reverseVec[0] && vec[1] === reverseVec[1]) {
                                $(`#attack-${dir.toLowerCase()}-btn`).disabled = true;
                                break;
                            }
                        }
                    }
                    break;
            }
        }

        // --- Game Logic ---

        // Event Handlers
        function handleBoardClick(e) {
            const cell = e.target.closest('.cell');
            if (!cell || !currentGame || playerIndex === -1) return;

            // Allow setup selection even if not "my turn"
            if (currentGame.phase === 'setup' && !currentGame.players[playerIndex].nexusLocation) {
                const r = parseInt(cell.dataset.r);
                const c = parseInt(cell.dataset.c);
                const myZoneStart = (playerIndex === 0) ? 0 : 5;
                const myZoneEnd = (playerIndex === 0) ? 5 : 10;
                const isMyZone = c >= myZoneStart && c < myZoneEnd;
                
                if (isMyZone && currentAction === 'setup-nexus-select' && !getUnitAt(r,c)) {
                    selectedUnitLocation = [r, c];
                    confirmNexusBtn.disabled = false;
                    renderBoard(); // Re-render to show selection
                }
                return;
            }

            // All other actions must be on my turn
            if (currentGame.turn !== playerIndex) return;

            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const myZoneStart = (playerIndex === 0) ? 0 : 5;
            const myZoneEnd = (playerIndex === 0) ? 5 : 10;
            const isMyZone = c >= myZoneStart && c < myZoneEnd;

            if (currentGame.phase === 'buyMove') {
                if (currentAction === 'place-pylon' && isMyZone) {
                    placeBuilding('pylon', r, c);
                } else if (currentAction === 'place-mirror' && isMyZone) {
                    placeBuilding('mirror', r, c);
                } else if (currentAction === 'move-nexus-select') {
                    const unit = getUnitAt(r, c);
                    if (unit && unit.type === 'nexus' && unit.isMine) {
                        selectedUnitLocation = [r, c];
                        currentAction = 'move-nexus-target';
                        renderBoard(); // Re-render for highlights
                    }
                } else if (currentAction === 'move-nexus-target') {
                    if (isValidNexusMove(selectedUnitLocation, [r,c]) && !getUnitAt(r,c)) {
                        moveNexus(selectedUnitLocation, [r, c]);
                    } else {
                        showError("Invalid move target.");
                        cancelCurrentAction();
                    }
                }
            }
        }

        async function confirmNexusPlacement() {
            if (!selectedUnitLocation) return showError("No location selected.");

            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            const [r, c] = selectedUnitLocation;
            
            // Create a deep copy to modify
            const newPlayers = JSON.parse(JSON.stringify(currentGame.players));
            newPlayers[playerIndex].nexusLocation = [r, c];
            
            let updateData = { players: newPlayers };
            let newLog = [...currentGame.log, `${newPlayers[playerIndex].displayName} (P${playerIndex+1}) placed Nexus.`];

            // Check if opponent has placed
            const opponent = newPlayers[(playerIndex + 1) % 2];
            if (opponent && opponent.nexusLocation) {
                // Both players have placed, start the game
                updateData.phase = 'buyMove';
                updateData.turn = 0; // P1 starts
                newLog.push(`Both players are ready. Game start!`);
                newLog.push(`${newPlayers[0].displayName} (P1)'s turn.`);
            }
            updateData.log = newLog;

            try {
                await updateDoc(gameRef, updateData);
                cancelCurrentAction(); // Clear selection
                // The onSnapshot listener will handle re-rendering
            } catch (error) {
                console.error("Confirm Nexus Error:", error);
                showError("Could not place Nexus.");
            }
        }

        async function placeBuilding(type, r, c) {
            const cost = (type === 'pylon') ? PYLON_COST : MIRROR_COST;
            if (getUnitAt(r,c)) return showError("Cell is occupied.");
            if (currentGame.energyPool < cost) return showError("Not enough Shared Energy.");
            if (currentBudget < cost) return showError("Not enough Budget.");
            
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            const newBuilding = { type, location: [r, c], hp: BUILDING_HP };
            
            // Deep copy players array to modify it
            const newPlayers = JSON.parse(JSON.stringify(currentGame.players));
            newPlayers[playerIndex].buildings.push(newBuilding);

            try {
                await updateDoc(gameRef, {
                    players: newPlayers,
                    energyPool: currentGame.energyPool - cost,
                    log: [...currentGame.log, `Player ${playerIndex+1} placed a ${type}.`]
                });
                // No need to update budget locally, onSnapshot will trigger renderGame
                cancelCurrentAction();
            } catch (error) {
                console.error("Place Building Error:", error);
                showError("Could not place building.");
            }
        }

        function isValidNexusMove(from, to) {
            if (!from || !to) return false;
            const [r1, c1] = from;
            const [r2, c2] = to;
            const dist = Math.abs(r1 - r2) + Math.abs(c1 - c2); // Manhattan distance
            
            // Basic range check
            if (dist === 0 || dist > NEXUS_MOVE_RANGE) return false;

            // Simple check: is it cardinal only?
            if(r1 !== r2 && c1 !== c2) return false; // Not cardinal move

            // TODO: Add path obstruction check
            // This basic check is fine for now
            return true;
        }

        async function moveNexus(from, to) {
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            const newPlayers = JSON.parse(JSON.stringify(currentGame.players));
            newPlayers[playerIndex].nexusLocation = to;

            try {
                await updateDoc(gameRef, {
                    players: newPlayers,
                    log: [...currentGame.log, `Player ${playerIndex+1} moved Nexus.`]
                });
                cancelCurrentAction();
            } catch (error) {
                console.error("Move Nexus Error:", error);
                showError("Could not move Nexus.");
            }
        }

        async function endBuyMovePhase() {
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            try {
                await updateDoc(gameRef, {
                    phase: 'attack',
                    log: [...currentGame.log, `Player ${playerIndex+1} is ready to attack.`]
                });
            } catch (error) {
                console.error("End Phase Error:", error);
                showError("Could not end phase.");
            }
        }

        async function skipAttack() {
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            const newTurn = (currentGame.turn + 1) % 2;
            const newEnergy = currentGame.energyPool + currentGame.pendingEnergyRefund;

            try {
                await updateDoc(gameRef, {
                    turn: newTurn,
                    phase: 'buyMove',
                    energyPool: newEnergy,
                    pendingEnergyRefund: 0, // Reset for new turn
                    lastShotVector: null, // No shot fired
                    log: [
                        ...currentGame.log,
                        `Player ${playerIndex+1} skipped attack.`,
                        (currentGame.pendingEnergyRefund > 0 ? `+${currentGame.pendingEnergyRefund} energy refunded to pool.` : ''),
                        `Turn ends. ${currentGame.players[newTurn].displayName} (P${newTurn + 1})'s turn.`
                    ].filter(Boolean) // Filter out empty refund message
                });
            } catch (error) {
                console.error("Skip Attack Error:", error);
                showError("Could not skip attack.");
            }
        }

        async function handleAttack(dx, dy) {
            if (playerIndex === -1 || !currentGame.players[playerIndex]) return;
            
            const myNexusLoc = currentGame.players[playerIndex].nexusLocation;
            if (!myNexusLoc) return;

            // Run laser simulation
            const { path, hits, logMsgs, finalGameState } = traceLaserPath(myNexusLoc, [dx, dy], currentGame);

            // Prepare update
            const gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'zero_sum_games', currentGameId);
            const newTurn = (currentGame.turn + 1) % 2;
            
            // Apply pending energy refund from *last* turn
            finalGameState.energyPool += currentGame.pendingEnergyRefund;
            
            // Set up pending refund for *next* turn
            const destroyedBuildings = hits.filter(h => h.type !== 'nexus' && h.hp <= 0).length;
            finalGameState.pendingEnergyRefund = destroyedBuildings; // 1 energy per destroyed building

            // Finalize state update
            finalGameState.lastShotVector = [dx, dy];
            finalGameState.turn = newTurn;
            finalGameState.phase = 'buyMove';
            
            // Build new log
            let newLog = [
                ...currentGame.log, 
                ...logMsgs, 
                `Laser path complete.`
            ];
            
            if (currentGame.pendingEnergyRefund > 0) {
                 newLog.push(`+${currentGame.pendingEnergyRefund} energy refunded to pool.`);
            }
            // Check if game ended before announcing next turn
            if (finalGameState.status !== 'gameOver') {
                 newLog.push(`Turn ends. ${finalGameState.players[newTurn].displayName} (P${newTurn + 1})'s turn.`);
            }

            finalGameState.log = newLog;

            try {
                await updateDoc(gameRef, finalGameState);
                animateLaser(path);
            } catch (error) {
                console.error("Attack Error:", error);
                showError("Could not process attack.");
            }
        }
        
        // --- Laser Logic ---
        function traceLaserPath(startLoc, direction, gameState) {
            let [r, c] = startLoc;
            let [dx, dy] = direction;
            
            let path = [[r, c]]; // Start at nexus
            let hits = [];
            let logMsgs = [`Player ${playerIndex+1} (${currentGame.players[playerIndex].displayName}) fires laser [${dx}, ${dy}] from (${r},${c})`];
            let newGameState = JSON.parse(JSON.stringify(gameState)); // Deep copy
            let players = newGameState.players;

            // Loop limited to 40 steps to prevent infinite bounces
            for (let i = 0; i < 40; i++) { 
                r += dx;
                c += dy;
                path.push([r, c]);

                // 1. Check Out of Bounds (Walls) & Handle Reflection
                const r_out = r < 0 || r >= BOARD_ROWS;
                const c_out = c < 0 || c >= BOARD_COLS;

                if (r_out || c_out) {
                    const [prevR, prevC] = path[path.length - 2]; // Get last valid spot
                    
                    logMsgs.push(`Laser reflects off boundary.`);

                    // Reflect vector
                    if (r_out) dx = -dx; // Hit Top/Bottom -> Flip Vertical
                    if (c_out) dy = -dy; // Hit Side -> Flip Horizontal

                    // Reset position to the wall (previous valid cell) so the next step comes OUT of the wall
                    r = prevR;
                    c = prevC;
                    
                    // Update direction for next iteration
                    direction = [dx, dy]; 
                    
                    // Note: We leave the out-of-bounds coordinate in 'path' 
                    // so the visual animation looks like it hits the edge before turning.
                    continue;
                }

                // 2. Check for Unit Hit
                let hitUnit = null;
                let hitOwnerIndex = -1;

                for (let pIdx = 0; pIdx < players.length; pIdx++) {
                    const player = players[pIdx];
                    // Check Nexus
                    if (player.nexusLocation && player.nexusLocation[0] === r && player.nexusLocation[1] === c) {
                        hitUnit = player; // Hit the player object to access nexusHP
                        hitUnit.type = 'nexus'; // Add type for logic
                        hitOwnerIndex = pIdx;
                        break;
                    }
                    // Check Buildings
                    for (let bIdx = 0; bIdx < player.buildings.length; bIdx++) {
                        const building = player.buildings[bIdx];
                        if (building.location[0] === r && building.location[1] === c) {
                            hitUnit = building;
                            hitOwnerIndex = pIdx;
                            break;
                        }
                    }
                    if (hitUnit) break;
                }
                
                // 3. Process Hit
                if (hitUnit) {
                    hits.push(hitUnit);
                    hitUnit.hp--;
                    const ownerName = players[hitOwnerIndex].displayName;

                    if (hitUnit.type === 'nexus') {
                        logMsgs.push(`HIT! ${ownerName}'s Nexus takes 1 damage!`);
                        if (hitUnit.nexusHP <= 0) {
                            logMsgs.push(`${ownerName}'s Nexus DESTROYED!`);
                            newGameState.status = 'gameOver';
                            newGameState.winner = playerIndex;
                        }
                        break; // Path stops at Nexus
                    } 
                    else if (hitUnit.type === 'pylon') {
                        logMsgs.push(`HIT! ${ownerName}'s Pylon hit!`);
                        if (hitUnit.hp <= 0) {
                            logMsgs.push(`Pylon at (${r},${c}) destroyed!`);
                            players[hitOwnerIndex].buildings = players[hitOwnerIndex].buildings.filter(
                                b => !(b.location[0] === r && b.location[1] === c)
                            );
                        }
                        break; // Path stops at Pylon
                    }
                    else if (hitUnit.type === 'mirror') {
                        logMsgs.push(`HIT! ${ownerName}'s Mirror reflects the beam!`);
                        if (hitUnit.hp <= 0) {
                            logMsgs.push(`Mirror at (${r},${c}) destroyed!`);
                             players[hitOwnerIndex].buildings = players[hitOwnerIndex].buildings.filter(
                                b => !(b.location[0] === r && b.location[1] === c)
                            );
                            // Path stops, mirror is destroyed
                            break;
                        }
                        
                        // Mirror reflects
                        // Implements NE (-1, 1) -> SE (1, 1) and E (0, 1) -> W (0, -1)
                        if (dx === 0) { // E or W
                            dy = -dy; // Flip horizontal
                        } else { // N, S, or diagonal
                            dx = -dx; // Flip vertical
                        }
                        direction = [dx, dy]; // Update direction
                        continue; // Continue path
                    }
                }
            }
            
            return { path, hits, logMsgs, finalGameState: newGameState };
        }

        function animateLaser(path) {
            let i = 0;
            const interval = setInterval(() => {
                if (i >= path.length) {
                    clearInterval(interval);
                    // Clear animation
                    $$('.laser-path').forEach(c => c.classList.remove('laser-path'));
                    return;
                }
                const [r, c] = path[i];
                const cell = $(`[data-r="${r}"][data-c="${c}"]`);
                if (cell) {
                    cell.classList.add('laser-path');
                }
                i++;
            }, 50);
        }

        // --- UI Helpers ---
        function cancelCurrentAction() {
            currentAction = null;
            selectedUnitLocation = null;
            // Re-enable setup button if we were in setup
            if (currentGame && currentGame.phase === 'setup') {
                confirmNexusBtn.disabled = true;
            }
            renderBoard(); // Re-render to clear highlights
        }

        function getUnitAt(r, c) {
            if (!currentGame || !currentGame.players) return null;
            for (let i = 0; i < currentGame.players.length; i++) {
                const player = currentGame.players[i];
                if (!player) continue; // Fix for player 2 not existing yet
                if (player.nexusLocation && player.nexusLocation[0] === r && player.nexusLocation[1] === c) {
                    return { type: 'nexus', hp: player.nexusHP, isMine: i === playerIndex, owner: i };
                }
                const building = player.buildings.find(b => b.location[0] === r && b.location[1] === c);
                if (building) {
                    return { ...building, isMine: i === playerIndex, owner: i };
                }
            }
            return null;
        }

        function showError(message) {
            // Non-blocking error
            const errorEl = document.createElement('div');
            errorEl.className = 'absolute top-5 right-5 bg-red-600 text-white p-3 rounded-lg shadow-lg z-50 animate-pulse';
            errorEl.textContent = message;
            document.body.appendChild(errorEl);
            setTimeout(() => {
                if (errorEl) errorEl.remove();
            }, 3000);
        }

        function showModal(message, showNewGame = false) {
            modalMessage.innerHTML = `<p>${message}</p>`;
            newGameBtn.classList.toggle('hidden', !showNewGame);
            modalView.classList.remove('hidden');
        }

        function closeModalandReset() {
            modalView.classList.add('hidden');
            if (unsubscribeGame) unsubscribeGame();
            gameView.classList.add('hidden');
            waitingRoomView.classList.add('hidden');
            showView('lobby'); // Go back to main menu
            currentGameId = null;
            currentGame = null;
            playerIndex = -1;
        }

        // --- UI View Management ---
        function showView(viewName) {
            [profileView, lobbyView, lobbyListView, createLobbyView, waitingRoomView, gameView, modalView].forEach(v => {
                if (v && v !== modalView) { // Modal is an overlay, don't hide it
                    v.classList.add('hidden');
                }
            });

            switch (viewName) {
                case 'profile':       if (profileView) profileView.classList.remove('hidden'); break;
                case 'lobby':         if (lobbyView) lobbyView.classList.remove('hidden'); break;
                case 'lobbyList':     if (lobbyListView) lobbyListView.classList.remove('hidden'); break;
                case 'createLobby':   if (createLobbyView) createLobbyView.classList.remove('hidden'); break;
                case 'waitingRoom':   if (waitingRoomView) waitingRoomView.classList.remove('hidden'); break;
                case 'game':          if (gameView) gameView.classList.remove('hidden'); break;
            }
        }

        function populateColorSelect(selectElement, defaultColor) {
            selectElement.innerHTML = '';
            AVAILABLE_COLORS.forEach(color => {
                const option = document.createElement('option');
                option.value = color;
                option.textContent = color;
                if (color === defaultColor) {
                    option.selected = true;
                }
                selectElement.appendChild(option);
            });
        }

        // --- Event Listeners ---
        window.addEventListener('load', initFirebase);
        
        // Profile
        saveProfileBtn.addEventListener('click', saveUserProfile);

        // Main Menu
        singlePlayerBtn.addEventListener('click', () => showError("Single player not yet implemented."));
        multiPlayerBtn.addEventListener('click', showLobbyList);

        // Lobby List
        refreshLobbiesBtn.addEventListener('click', refreshLobbies);
        showCreateLobbyBtn.addEventListener('click', showCreateLobby);
        backToMainMenuBtn.addEventListener('click', () => showView('lobby'));

        // Create Lobby
        createLobbyBtn.addEventListener('click', createLobby);
        cancelCreateLobbyBtn.addEventListener('click', () => showView('lobbyList'));

        // Waiting Room
        startGameBtn.addEventListener('click', startGame);
        leaveLobbyBtn.addEventListener('click', leaveLobby);
        
        // Game
        gameBoard.addEventListener('click', handleBoardClick);
        newGameBtn.addEventListener('click', closeModalandReset);
        
        // Buy/Move Controls
        placePylonBtn.addEventListener('click', () => { currentAction = 'place-pylon'; renderBoard(); });
        placeMirrorBtn.addEventListener('click', () => { currentAction = 'place-mirror'; renderBoard(); });
        moveNexusBtn.addEventListener('click', () => { currentAction = 'move-nexus-select'; renderBoard(); });
        cancelActionBtn.addEventListener('click', cancelCurrentAction);
        endPhaseBtn.addEventListener('click', endBuyMovePhase);
        bottomNextPhaseBtn.addEventListener('click', endBuyMovePhase);
        
        // Setup Controls
        confirmNexusBtn.addEventListener('click', confirmNexusPlacement);

        // Attack Controls
        // --- FIX: Added event listeners ---
        $$('#attack-controls button[data-dir]').forEach(btn => {
            btn.addEventListener('click', () => {
                const dir = btn.dataset.dir;
                if (DIRECTIONS[dir]) {
                    const [dx, dy] = DIRECTIONS[dir];
                    handleAttack(dx, dy);
                }
            });
        });
        skipAttackBtn.addEventListener('click', skipAttack);

    </script>

    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Use a more sci-fi mono font for headers */
        .font-sci-mono {
            font-family: 'Orbitron', 'Courier New', monospace; /* Fallback to monospace */
        }
        
        /* Link a sci-fi font (optional, but nice) */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Orbitron:wght@400;700&display=swap');

        /* Board cell styling */
        .cell {
            box-shadow: inset 0 0 2px rgba(167, 139, 250, 0.2);
        }
        .shroud-wall {
            background-image: repeating-linear-gradient(
                45deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 1px,
                transparent 1px,
                transparent 10px
            );
        }
        
        /* Unit styling */
        .unit {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.9;
            filter: drop-shadow(0 0 8px currentColor);
        }
        .hp {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.7rem;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 0 3px;
            border-radius: 2px;
        }

        /* Laser animation */
        @keyframes laser-flash {
            0%, 100% { background-color: rgba(255, 0, 0, 0.8); box-shadow: 0 0 10px 5px rgba(255, 0, 0, 0.7); }
            50% { background-color: rgba(255, 100, 100, 0.8); box-shadow: 0 0 15px 8px rgba(255, 100, 100, 0.7); }
        }
        .laser-path {
            animation: laser-flash 0.2s linear;
            z-index: 10;
        }

        /* Custom scrollbar */
        #game-log::-webkit-scrollbar,
        #lobby-list-container::-webkit-scrollbar {
            width: 8px;
        }
        #game-log::-webkit-scrollbar-track,
        #lobby-list-container::-webkit-scrollbar-track {
            background: #2d3748; /* gray-800 */
        }
        #game-log::-webkit-scrollbar-thumb,
        #lobby-list-container::-webkit-scrollbar-thumb {
            background: #4a5568; /* gray-600 */
            border-radius: 4px;
        }
        #game-log::-webkit-scrollbar-thumb:hover,
        #lobby-list-container::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-200 min-h-screen p-4 md:p-8 flex items-center justify-center">

    <!-- Main Application Container -->
    <div id="app" class="w-full max-w-7xl mx-auto">

        <!-- Profile View (Hidden by default) -->
        <div id="profile-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Welcome!</h1>
            <p class="text-center text-gray-300 mb-4">Please create your profile to play.</p>
            <div class="space-y-4">
                <div>
                    <label for="profile-display-name" class="block text-sm font-medium text-gray-400 mb-1">Display Name</label>
                    <input id="profile-display-name" type="text" placeholder="Enter your name" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none">
                </div>
                <div>
                    <label for="profile-color-select" class="block text-sm font-medium text-gray-400 mb-1">Preferred Color</label>
                    <select id="profile-color-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none">
                        <!-- Colors populated by JS -->
                    </select>
                </div>
                <button id="save-profile-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg">
                    Save Profile
                </button>
            </div>
        </div>

        <!-- Lobby View -->
        <div id="lobby-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Zero-Sum Defense</h1>
            <div class="mb-4 p-3 bg-gray-900 rounded-lg">
                <p class="text-sm text-gray-400">Welcome,</p>
                <p id="user-display-name-display" class="font-mono text-lg break-all">...</p>
                <p class="text-xs text-gray-500 mt-1">User ID: <span id="user-id-display" class="font-mono break-all">Loading...</span></p>
            </div>
            <div class="space-y-4">
                <button id="single-player-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg disabled:opacity-50" disabled>
                    Singleplayer (Soon)
                </button>
                <button id="multi-player-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg">
                    Multiplayer
                </button>
            </div>
        </div>
        
        <!-- Lobby List View -->
        <div id="lobby-list-view" class="hidden w-full max-w-lg mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Open Lobbies</h1>
            <div class="flex justify-between mb-4">
                <button id="back-to-main-menu-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-all">&larr; Main Menu</button>
                <button id="refresh-lobbies-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-4 rounded-lg transition-all">Refresh</button>
            </div>
            <div id="lobby-list-container" class="space-y-3 max-h-96 overflow-y-auto p-2 bg-gray-900/50 rounded-lg">
                <!-- Lobbies populated by JS -->
            </div>
            <button id="show-create-lobby-btn" class="w-full bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mt-6">
                + Create New Lobby
            </button>
        </div>

        <!-- Create Lobby View -->
        <div id="create-lobby-view" class="hidden w-full max-w-md mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h1 class="text-3xl font-bold text-center mb-6 font-sci-mono text-cyan-400">Create Lobby</h1>
            <div class="space-y-4">
                <div>
                    <label for="lobby-name-input" class="block text-sm font-medium text-gray-400 mb-1">Lobby Name</label>
                    <input id="lobby-name-input" type="text" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none">
                </div>
                <div>
                    <label for="energy-pool-select" class="block text-sm font-medium text-gray-400 mb-1">Starting Energy</label>
                    <select id="energy-pool-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none">
                        <option value="10">Standard (10)</option>
                        <option value="20">High (20)</option>
                        <option value="5">Low (5)</option>
                    </select>
                </div>
                <div>
                    <label for="host-color-select" class="block text-sm font-medium text-gray-400 mb-1">Your Color</label>
                    <select id="host-color-select" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:border-indigo-500 focus:ring-1 focus:ring-indigo-500 outline-none">
                        <!-- Colors populated by JS -->
                    </select>
                </div>
                <div class="flex gap-4">
                    <button id="cancel-create-lobby-btn" class="w-1/2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-lg transition-all shadow-lg">
                        Cancel
                    </button>
                    <button id="create-lobby-btn" class="w-1/2 bg-green-600 hover:bg-green-500 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg">
                        Create
                    </button>
                </div>
            </div>
        </div>

        <!-- Waiting Room View -->
        <div id="waiting-room-view" class="hidden w-full max-w-lg mx-auto p-6 bg-gray-800/50 rounded-lg shadow-xl backdrop-blur-md border border-indigo-500/30">
            <h2 class="text-2xl font-bold text-center mb-2 font-sci-mono text-cyan-400">Waiting Room</h2>
            <h3 id="waiting-lobby-name" class="text-xl text-center text-gray-300 mb-6">...</h3>
            
            <div class="grid grid-cols-2 gap-4 text-center mb-6">
                <!-- Player 1 Box -->
                <div class="p-4 bg-gray-900/50 rounded-lg">
                    <p class="text-sm text-gray-400 mb-1">Player 1 (Host)</p>
                    <p id="waiting-player1-name" class="text-lg font-bold">...</p>
                    <div id="waiting-player1-color" class="p-2 rounded-lg border-2 mt-2">...</div>
                </div>
                <!-- Player 2 Box -->
                <div class="p-4 bg-gray-900/50 rounded-lg">
                    <p class="text-sm text-gray-400 mb-1">Player 2</p>
                    <p id="waiting-player2-name" class="text-lg font-bold">...</p>
                    <div id="waiting-player2-color" class="p-2 rounded-lg border-2 mt-2">...</div>
                </div>
            </div>
            
            <button id="start-game-btn" class="w-full bg-green-600 hover:bg-green-500 disabled:bg-gray-600 disabled:opacity-50 text-white font-bold py-3 px-4 rounded-lg text-lg transition-all shadow-lg mb-3">
                Start Game
            </button>
            <button id="leave-lobby-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg transition-all shadow-lg">
                Leave Lobby
            </button>
        </div>


        <!-- Game View -->
        <div id="game-view" class="hidden w-full">
            <!-- Header / Status Panel -->
            <div class="mb-4 p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 text-center">
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">Game ID</span>
                    <span id="game-id-display" class="text-sm break-all">...</span>
                </div>
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">You Are</span>
                    <span id="player-number" class="text-lg font-bold">...</span>
                </div>
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">Current Turn</span>
                    <span id="current-turn" class="text-lg font-bold">...</span>
                </div>
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">Phase</span>
                    <span id="current-phase" class="text-lg font-bold">...</span>
                </div>
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">Energy Pool</span>
                    <span id="energy-pool" class="text-lg font-bold text-cyan-400">10</span>
                </div>
                <div class="font-sci-mono">
                    <span class="text-xs text-gray-400 block">Your Budget</span>
                    <span id="player-budget" class="text-lg font-bold text-green-400">$0</span>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="flex flex-col lg:flex-row gap-4">
                
                <!-- Game Board -->
                <div class="flex-grow">
                    <div id="game-board" class="grid grid-cols-10 gap-1 bg-gray-900/50 p-2 rounded-lg border border-indigo-500/30">
                        <!-- Cells generated by JS -->
                    </div>
                </div>

                <!-- Controls & Log -->
                <div class="w-full lg:w-80 xl:w-96 flex-shrink-0 flex flex-col gap-4">
                    
                    <!-- Control Panel -->
                    <div id="control-panel" class="p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">CONTROLS</h3>
                        
                        <!-- Setup Controls -->
                        <div id="setup-controls" class="hidden text-center">
                            <p class="text-lg text-yellow-300 animate-pulse">Select a cell and confirm your Nexus location.</p>
                            <button id="confirm-nexus-btn" class="w-full mt-4 bg-green-600 hover:bg-green-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all text-lg" disabled>
                                Confirm Placement
                            </button>
                        </div>
                        
                        <!-- Setup Waiting Message -->
                        <p id="setup-waiting-msg" class="hidden text-lg text-gray-400 animate-pulse text-center">
                            Waiting for opponent to place Nexus...
                        </p>

                        <!-- Buy/Move Controls -->
                        <div id="buy-move-controls" class="hidden space-y-3">
                            <div class="grid grid-cols-2 gap-2">
                                <button id="place-pylon-btn" class="w-full bg-cyan-700 hover:bg-cyan-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all">Pylon (1E)</button>
                                <button id="place-mirror-btn" class="w-full bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all">Mirror (1E)</button>
                            </div>
                            <button id="move-nexus-btn" class="w-full bg-yellow-600 hover:bg-yellow-500 disabled:bg-gray-600 text-white font-bold p-3 rounded-lg transition-all">Move Nexus</button>
                            <button id="cancel-action-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold p-2 rounded-lg transition-all text-sm">Cancel Action</button>
                            <hr class="border-gray-600 my-3">
                            <button id="end-phase-btn" class="w-full bg-green-600 hover:bg-green-500 text-white font-bold p-3 rounded-lg transition-all text-lg">Ready to Attack</button>
                        </div>

                        <!-- Attack Controls -->
                        <div id="attack-controls" class="hidden">
                            <p class="text-center mb-3 text-lg text-red-400 animate-pulse">Select Attack Vector</p>
                            <div class="grid grid-cols-3 gap-2 w-48 mx-auto">
                                <button id="attack-nw-btn" data-dir="NW" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">NW</button>
                                <button id="attack-n-btn" data-dir="N" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">N</button>
                                <button id="attack-ne-btn" data-dir="NE" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">NE</button>
                                <button id="attack-w-btn" data-dir="W" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">W</button>
                                <div class="aspect-square flex items-center justify-center text-red-400"><svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.539 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.784.57-1.838-.196-1.539-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.783-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" /></svg></div>
                                <button id="attack-e-btn" data-dir="E" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">E</button>
                                <button id="attack-sw-btn" data-dir="SW" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">SW</button>
                                <button id="attack-s-btn" data-dir="S" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">S</button>
                                <button id="attack-se-btn" data-dir="SE" class="aspect-square bg-red-800 hover:bg-red-700 disabled:bg-gray-600 rounded-lg font-bold transition-all">SE</button>
                            </div>
                            <hr class="border-gray-600 my-3">
                            <button id="skip-attack-btn" class="w-full bg-gray-600 hover:bg-gray-500 text-white font-bold p-3 rounded-lg transition-all text-lg">
                                Skip Attack & End Turn
                            </button>
                        </div>

                        <!-- Waiting Controls (New) -->
                        <div id="waiting-controls" class="hidden text-center">
                            <p class="text-lg text-gray-400 animate-pulse">Waiting for opponent...</p>
                        </div>
                    </div>

                    <!-- Game Log -->
                    <div class="flex-grow p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30 min-h-[200px] lg:min-h-0">
                        <h3 class="text-xl font-bold mb-4 text-center font-sci-mono text-cyan-400">EVENT LOG</h3>
                        <div id="game-log" class="h-48 lg:h-full lg:max-h-96 overflow-y-auto space-y-2 pr-2 font-mono">
                            <!-- Log messages generated by JS -->
                        </div>
                    </div>

                    <!-- New Phase Indicator (Below Log) -->
                    <div class="p-4 bg-gray-800/50 rounded-lg shadow-lg backdrop-blur-md border border-indigo-500/30">
                        <h3 class="text-lg font-bold mb-2 text-center font-sci-mono text-cyan-400">Current Phase</h3>
                        <p id="bottom-phase-display" class="text-2xl font-bold text-center text-gray-300">...</p>
                        <button id="bottom-next-phase-btn" class="hidden w-full mt-4 bg-green-600 hover:bg-green-500 text-white font-bold p-3 rounded-lg transition-all text-lg">
                            Ready to Attack
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modal View -->
        <div id="modal-view" class="hidden fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4">
            <div class="bg-gray-800 p-8 rounded-lg shadow-xl border border-indigo-500/50 max-w-lg w-full text-center">
                <div id="modal-message" class="text-2xl mb-6">...</div>
                <button id="new-game-btn" class="hidden bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg text-lg transition-all">
                    Back to Lobby
                </button>
            </div>
        </div>

    </div>

</body>
</html>